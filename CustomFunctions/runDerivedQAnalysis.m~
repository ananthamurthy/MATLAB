function [derivedQOutput] = runDerivedQAnalysis(DATA, derivedQInput)

delta = derivedQ.delta;
skipFrames = derivedQInput.skipFrames;

nCells = size(DATA, 1);
nTrials = size(DATA, 2);
%nFrames = size(DATA, 3);

%NOTE: 'DATA' is organized as (cells, trials, frames)
%2D DATA (cells, all frames)
for cell = 1:nCells
    DATA_2D(cell, :) = reshape(squeeze(DATA(cell, :, :))', 1, []);
end

%Preallocation
hitTrials = zeros(nCells, nTrials);
Q1 = nan(nCells, 1);
Q2 = nan(nCells, 1);
peakTimeBin = nan(nCells, 1);
peakTrialTimeBin = nan(nCells, nTrials);
maxSignal = nan(nCells, 1);
HTR = nan(nCells, 1);
NbyS1 = nan(nCells, 1);
NbyS2 = nan(nCells, 1);
timeCells = nan(nCells, 1);

%Preallocation - for event library
s.nEvents = 0;
s.eventStartIndices = [];
s.eventWidths = [];
eventLibrary_2D = repmat(s, 1, nCells);
clear s
cellMean = zeros(nCells, 1);
cellStddev = zeros(nCells, 1);
binaryData = zeros(nCells, 1);

for cell = 1:nCells
    [ETH, trialAUCs, nBins] = getETH(DATA, delta, skipFrames);
    
    %Find ETH Peak
    [~, peakTimeBin(cell)] = max(ETH(cell, :));
    
    for trial = 1:nTrials
        %Find Trial-wise peak time bins
        [~, peakTrialTimeBin(cell, trial)] = max(trialAUCs(cell, trial, :));
        
        %Find Hit Trials
        if peakTrialTimeBin(cell, trial) == peakTimeBin(cell)
            hitTrials(cell, trial) = 1;
        else
            hitTrials(cell, trial) = 0;
        end
    end
    %Find Hit Trial Ratio (HTR)
    HTR(cell) = sum(hitTrials(cell, :))/nTrials;
    
    a = derivedQInput.alpha;
    %Establish Noise by Signal - 2 measures
    maxSignal(cell) = max(DATA_2D(cell, :)); %Should I consider a percentile value?
    
    noiseVar1 = evar(DATA_2D(cell, :));
    NbyS1(cell) = sqrt(noiseVar1)/maxSignal(cell);
    
    noiseVar2 = estimatenoise(DATA_2D(cell, :));
    NbyS2(cell) = sqrt(noiseVar2)/maxSignal(cell);
    
    b = params4Q.beta; 
    %Find all event widths
    %Use real 2D data to curate a library
    disp('Scanning for calcium events ...')
    sampledCellActivity = squeeze(DATA_2D(cell, :));
    cellMean(cell) = mean(sampledCellActivity);
    cellStddev(cell) = std(sampledCellActivity);
    logicalIndices = sampledCellActivity > (cellMean(cell) + 2* cellStddev(cell));
    binaryData(logicalIndices, 1) = 1;
    minNumberOf1s = 3;
    %[nEvents, StartIndices, Widths] = findConsecutiveOnes(binaryData, minNumberOf1s);
    [eventLibrary_2D(cell).nEvents, eventLibrary_2D(cell).eventStartIndices, eventLibrary_2D(cell).eventWidths] = findConsecutiveOnes(binaryData, minNumberOf1s);
    
    clear binaryData
    clear Events
    clear StartIndices
    clear Lengths
    
    disp('... done!')
    aew = eventLibrary_2D(cell).eventWidths;
%     sdAEW = nanstd(aew(ht)); %Only Hit Trials
%     mAEW = nanmean(aew(ht)); %Only Hit Trials
    sdAEW = nanstd(aew); %All events
    mAEW = nanmean(aew); %All events
    SDbyMEW = sdAEW/mAEW;
    
    g = params4Q.gamma;
    %Find Imprecision or Pad (p)
    for trial = 1:nTrials
        p(cell) = peakTimeBin(cell) - peakTrialTimeBin(cell, trial);
    end
    sdp = std(p);
    sw = params4Q.stimulusWindow;
    SDPbySW = sdp/sw;
    
    Q1(cell) = HTR(cell) * exp(-1 * ((a * NbyS1(cell)) + (b * SDbyMEW(cell)) + (g * SDPbySW(cell))));
    Q2(cell) = HTR(cell) * exp(-1 * ((a * NbyS2(cell)) + (b * SDbyMEW(cell)) + (g * SDPbySW(cell))));
end
end